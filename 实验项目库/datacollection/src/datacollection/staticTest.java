package datacollection;

/**
 * 非静态类中可以写静态方法，类似，非静态方法中可以调用静态方法一样；反过来的话就不可以，必须new
 * 
 * 静态类中的话
*/

public class staticTest {
	
	int a=4;
	int b= 5;
	
    int	method(){
    	
    	 method2();
    	int c= a+b;
		return c;
	}
    
   static void method2() {
	    //test.method();这种事错误的
    	staticTest test =new staticTest();
    	test.method();
      /**这种方式可以调用静态方法，因为静态方法是共享的，没有必要new，不需要实例，也就允许有this，
    	*在编译的时候就能知道具体的参数,所以提前加载，但是普通方法不行，普通方法在类加载的时候，
    	 * 并不知道没有实例，所以会有空指针异常，所以静态方法中要想调用这种方法，就必要new一下，然后虚拟机
    	 * 加载编译的时候就知道这个不是空指针的引用
    	 * 另外，所谓不能提前加载时候是因为，动态绑定，其实就是多态，其他情况也可以加载，只要是按照语法，new
    	 * 一个实例，就可以记载了，因为机器就能知道引用额地址，之所以出现那么多的静态的加载的条条框框，是由于静态
    	 * 方法不能和其他普通方法一样，任意调用方法，因为是在运行期间加载的，是最后加载，自己调用的所有东西都会
    	 * 为自己准备好
*/    
    	}
   
   private static class test03{//可以声明为静态的类

	    int	method3543(){
	    	
			return 0;
	    }
	}
}

/**要弄清楚：
 * 01为什么只能声明一个public的class：
 * 答：每个编译单元（文件）都只有一个public   类。因为每个编译单元都只能有一个公共接口，用public类来表现。
 * 为什么只能是静态内部类
 * 
 * 重要的是：定义成外部顶级的静态类没有什么意义，定义成静态的好处就是可以直接.被调用，而外部类这样定义的话，就意味
 * 可以被上一级.调用，但是没有上级的，所以么意思；
 * 			所有只有静态内部类，好处就有，例如可以直接out.inner.静态方法进行链式调用，这个好处，否者就要new一下
 * 		获得实例变量才行；
 * 			静态内部类中是可以进行定义静态方法和非静态的方法的，和这方面和普通的一样，只不过区别就是：
 * 		可以定义，因为，静态内部类也是一个类，类里面可以定义静态成员，也可以定义非静态成员。对于 在静态
 * 	内部类里面的静态成员和非静态成员的区别在于：静态内部类的非静态成员可以访问外部类的非静态变量，而静态成员则不可以，（需要new一下获取实例）。
 * 
 * 问题关于静态和非静态之间调用调用的问题，比较乱，只是说静态能够调用非静态，只不过需要new一下获取实例	
 * 
 * 
 * 
 * 
 * 
 * 
 * 答：01   如果一个类要被声明为static的，只有一种情况，就是静态内部类。
    静态内部类实际上与普通类（即类名必须与文件名一样的顶级类）一样，只是静态内部类在某一类的内部定义了而已，
    既然是类，要想使用就必须实例化。概念上与静态变量、静态方法是不一样的，不要被“静态”两个字迷惑了（不要
    以为凡是静态的东西就不需要实例化就可以直接使用，静态内部类是有区别），而且只有静态内部类，
    而没有静态类（顶级类）的概念。
    02普通内部类可以访问其外部类的各种类型成员，但是静态内部类只能访问静态成员
普通内部类里面不能定义各种静态的成员（包括静态变量、静态方法、静态代码块和静态内部类），而静态内部类中则可以； 
静态变量和静态方法会出现这个语法错误(static methods can only be declared in a static or top level type)
意思就是static方法只能在静态或者顶级类型（顶级类型应该就是外部类中）中声明，当然static变量和static内部类也是一样的道理。
原因在静态变量和静态方法都只需要通过类名就能访问，不必通过任何实例化对象；而普通内部类的初始化要利用外部类的实例化对象，这明显违背了static的设计初衷。
静态代码块会出现这个语法错误(Cannot define static initializer in inner type Outer.Inner)意思是不能在内部类中定义静态的初始化程序。 
原因跟以上的差不多，static声明的成员只能为类所共有，而不能仅属于一个实例化对象，通俗点来说就是不管有多少层的引用，都只能是类来引用而不能是对象。
 * 
 * */

 class test056{//不能是静态的类

    int	method(){
    	staticTest.method2();
    	//不可以调用上面类中的 方法
		return 0;
    }
	
} 